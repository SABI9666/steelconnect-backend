// src/routes/analysis.js - Contractor Analytics Portal
import express from 'express';
import multer from 'multer';
import * as XLSX from 'xlsx';
import { authenticateToken } from '../middleware/authMiddleware.js';
import { adminDb } from '../config/firebase.js';

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024 } });

// Protect all routes with authentication
router.use(authenticateToken);

// === HELPER: Parse spreadsheet buffer into structured data ===
function parseSpreadsheet(buffer, originalname) {
    const workbook = XLSX.read(buffer, { type: 'buffer', cellDates: true });
    const sheets = {};
    for (const sheetName of workbook.SheetNames) {
        const ws = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(ws, { defval: '' });
        if (jsonData.length > 0) {
            sheets[sheetName] = jsonData;
        }
    }
    return sheets;
}

// === HELPER: Auto-detect chart types and build dashboard config ===
function autoGenerateDashboardConfig(sheets, frequency) {
    const configs = [];
    for (const [sheetName, rows] of Object.entries(sheets)) {
        if (rows.length === 0) continue;
        const headers = Object.keys(rows[0]);
        let labelCol = null;
        const numericCols = [];
        for (const h of headers) {
            const sample = rows[0][h];
            if (!labelCol && (typeof sample === 'string' || sample instanceof Date ||
                /date|time|day|week|month|year|period|label|name|category/i.test(h))) {
                labelCol = h;
            } else if (typeof sample === 'number' || (!isNaN(parseFloat(sample)) && sample !== '')) {
                numericCols.push(h);
            }
        }
        if (!labelCol && headers.length > 0) labelCol = headers[0];
        if (numericCols.length === 0) continue;

        const labels = rows.map(r => {
            const val = r[labelCol];
            if (val instanceof Date) return val.toLocaleDateString();
            return String(val);
        });

        const datasets = numericCols.map(col => ({
            label: col,
            data: rows.map(r => parseFloat(r[col]) || 0)
        }));

        let chartType = 'bar';
        if (numericCols.length === 1 && rows.length <= 8) chartType = 'doughnut';
        else if (rows.length > 10) chartType = 'line';
        else if (numericCols.length >= 2) chartType = 'line';

        const kpis = numericCols.slice(0, 4).map(col => {
            const values = rows.map(r => parseFloat(r[col]) || 0);
            const total = values.reduce((a, b) => a + b, 0);
            const avg = total / values.length;
            const max = Math.max(...values);
            const min = Math.min(...values);
            const prevHalf = values.slice(0, Math.floor(values.length / 2));
            const currHalf = values.slice(Math.floor(values.length / 2));
            const prevAvg = prevHalf.length ? prevHalf.reduce((a, b) => a + b, 0) / prevHalf.length : 0;
            const currAvg = currHalf.length ? currHalf.reduce((a, b) => a + b, 0) / currHalf.length : 0;
            const trend = prevAvg > 0 ? (((currAvg - prevAvg) / prevAvg) * 100).toFixed(1) : 0;
            return { label: col, total: Math.round(total * 100) / 100, avg: Math.round(avg * 100) / 100, max, min, trend: parseFloat(trend) };
        });

        configs.push({
            sheetName, chartType, labelColumn: labelCol,
            dataColumns: numericCols, labels, datasets, kpis, rowCount: rows.length
        });
    }
    return configs;
}

// === CONTRACTOR SHEET UPLOAD - Auto-generates dashboard, sends to admin for approval ===
// Supports: file upload (.xlsx, .xls, .csv) AND/OR Google Sheet link
// POST /api/analysis/upload-sheet
router.post('/upload-sheet', upload.single('spreadsheet'), async (req, res) => {
    try {
        const userEmail = req.user.email;
        const userName = req.user.name || req.user.displayName || 'Unknown User';

        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email not found' });
        }

        const { title, frequency, description, dataType, googleSheetUrl } = req.body;
        const hasFile = !!req.file;
        const hasLink = !!(googleSheetUrl && googleSheetUrl.trim());

        if (!hasFile && !hasLink) {
            return res.status(400).json({ success: false, message: 'Please upload a spreadsheet file (.xlsx, .xls, .csv) or provide a Google Sheet link' });
        }

        let sheets = {};
        let sheetNames = [];
        let dashboardCharts = [];
        let fileName = '';
        let fileSize = 0;

        // Process uploaded file if present
        if (hasFile) {
            sheets = parseSpreadsheet(req.file.buffer, req.file.originalname);
            sheetNames = Object.keys(sheets);
            fileName = req.file.originalname;
            fileSize = req.file.size;

            if (sheetNames.length === 0) {
                return res.status(400).json({ success: false, message: 'No valid data found in the uploaded file. Please check your spreadsheet.' });
            }

            dashboardCharts = autoGenerateDashboardConfig(sheets, frequency || 'daily');

            if (dashboardCharts.length === 0) {
                return res.status(400).json({ success: false, message: 'Could not extract numeric data from the spreadsheet. Ensure columns have numeric values.' });
            }
        }

        // Store in Firestore 'dashboards' collection with status 'pending' for admin approval
        const dashboardData = {
            title: title || (hasFile ? `Dashboard - ${fileName}` : 'Dashboard - Google Sheet'),
            description: description || '',
            dataType: dataType || 'Production Update',
            contractorEmail: userEmail,
            contractorName: userName,
            frequency: frequency || 'daily',
            fileName: fileName || null,
            fileSize: fileSize || 0,
            googleSheetUrl: hasLink ? googleSheetUrl.trim() : null,
            sheetNames,
            charts: dashboardCharts,
            rawData: hasFile ? sheets : null,
            status: 'pending',
            uploadedBy: 'contractor',
            createdBy: userEmail,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            approvedAt: null,
            approvedBy: null
        };

        const docRef = await adminDb.collection('dashboards').add(dashboardData);
        console.log(`[ANALYSIS] Contractor ${userEmail} uploaded ${hasFile ? 'file' : ''}${hasFile && hasLink ? ' + ' : ''}${hasLink ? 'Google Sheet link' : ''} -> Dashboard ${docRef.id} created (pending approval)`);

        const message = hasFile
            ? `Dashboard auto-generated with ${dashboardCharts.length} charts! Sent to admin for approval.`
            : 'Google Sheet link submitted. Dashboard will be generated by admin after review.';

        res.json({
            success: true,
            message,
            dashboardId: docRef.id,
            chartsGenerated: dashboardCharts.length,
            sheetsProcessed: sheetNames.length
        });

    } catch (error) {
        console.error('[ANALYSIS] Sheet upload error:', error);
        res.status(500).json({ success: false, message: 'Failed to process your data. Please try again.' });
    }
});

// GET /api/analysis/my-dashboards - Get all dashboards for this contractor (pending + approved + rejected)
router.get('/my-dashboards', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email not found' });

        const snapshot = await adminDb.collection('dashboards')
            .where('contractorEmail', '==', userEmail)
            .get();

        const dashboards = snapshot.docs.map(doc => {
            const d = doc.data();
            return {
                _id: doc.id,
                title: d.title,
                description: d.description,
                dataType: d.dataType || 'Production Update',
                frequency: d.frequency,
                fileName: d.fileName,
                googleSheetUrl: d.googleSheetUrl || null,
                status: d.status,
                chartsCount: (d.charts || []).length,
                charts: d.status === 'approved' ? d.charts : null,
                sheetNames: d.sheetNames,
                createdAt: d.createdAt,
                approvedAt: d.approvedAt,
                updatedAt: d.updatedAt
            };
        });

        dashboards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        res.json({ success: true, dashboards });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching my-dashboards:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboards' });
    }
});

// DELETE /api/analysis/dashboard/:id - Contractor can delete their own pending dashboard
router.delete('/dashboard/:id', async (req, res) => {
    try {
        const userEmail = req.user.email;
        const doc = await adminDb.collection('dashboards').doc(req.params.id).get();
        if (!doc.exists) return res.status(404).json({ success: false, message: 'Dashboard not found' });

        const data = doc.data();
        if (data.contractorEmail !== userEmail) {
            return res.status(403).json({ success: false, message: 'Access denied' });
        }
        if (data.status !== 'pending') {
            return res.status(400).json({ success: false, message: 'Can only delete pending dashboards' });
        }

        await adminDb.collection('dashboards').doc(req.params.id).delete();
        res.json({ success: true, message: 'Dashboard deleted successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error deleting dashboard:', error);
        res.status(500).json({ success: false, message: 'Failed to delete dashboard' });
    }
});

// === LEGACY ENDPOINTS (kept for backwards compatibility) ===

// GET /api/analysis/my-request - Get contractor's analysis request
router.get('/my-request', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email not found' });
        }

        const snapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .orderBy('createdAt', 'desc')
            .limit(1)
            .get();

        if (snapshot.empty) {
            return res.json({ success: true, request: null });
        }

        const doc = snapshot.docs[0];
        const data = doc.data();

        res.json({
            success: true,
            request: {
                _id: doc.id,
                dataType: data.dataType || 'Production Update',
                frequency: data.frequency || 'Daily',
                description: data.description || '',
                googleSheetUrl: data.googleSheetUrl || '',
                vercelUrl: data.vercelUrl || null,
                status: data.vercelUrl ? 'completed' : 'pending',
                adminNotes: data.adminNotes || '',
                createdAt: data.createdAt,
                updatedAt: data.updatedAt
            }
        });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching contractor request:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch analysis request' });
    }
});

// POST /api/analysis/submit-request - Submit new analysis request (legacy)
router.post('/submit-request', async (req, res) => {
    try {
        const { dataType, frequency, googleSheetUrl, description } = req.body;
        const userEmail = req.user.email;
        const userName = req.user.name || req.user.displayName || 'Unknown User';
        const userId = req.user.uid || req.user.id || null;

        if (!googleSheetUrl || !description) {
            return res.status(400).json({ success: false, message: 'Data source URL and description are required' });
        }
        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email is required' });
        }
        if (!googleSheetUrl.includes('http')) {
            return res.status(400).json({ success: false, message: 'Please provide a valid URL' });
        }

        const existingSnapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .where('vercelUrl', '==', null)
            .get();

        if (!existingSnapshot.empty) {
            return res.status(400).json({ success: false, message: 'You already have a pending analysis request' });
        }

        const requestData = {
            contractorEmail: userEmail,
            contractorName: userName,
            dataType: dataType || 'Production Update',
            frequency: frequency || 'Daily',
            googleSheetUrl: googleSheetUrl,
            description: description,
            vercelUrl: null,
            adminNotes: '',
            status: 'pending',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        if (userId) requestData.contractorId = userId;

        const docRef = await adminDb.collection('analysis_requests').add(requestData);

        res.json({ success: true, message: 'Business analytics request submitted successfully', requestId: docRef.id });
    } catch (error) {
        console.error('[ANALYSIS] Error submitting request:', error);
        res.status(500).json({ success: false, message: 'Failed to submit business analytics request' });
    }
});

// PUT /api/analysis/request/:requestId - Update analysis request
router.put('/request/:requestId', async (req, res) => {
    try {
        const { requestId } = req.params;
        const { dataType, frequency, googleSheetUrl, description } = req.body;
        const userEmail = req.user.email;

        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const requestDoc = await adminDb.collection('analysis_requests').doc(requestId).get();
        if (!requestDoc.exists) return res.status(404).json({ success: false, message: 'Analysis request not found' });

        const requestData = requestDoc.data();
        if (requestData.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Not authorized' });
        if (requestData.vercelUrl) return res.status(400).json({ success: false, message: 'Cannot update after report has been uploaded' });

        await adminDb.collection('analysis_requests').doc(requestId).update({
            dataType: dataType || requestData.dataType,
            frequency: frequency || requestData.frequency,
            googleSheetUrl: googleSheetUrl || requestData.googleSheetUrl,
            description: description || requestData.description,
            updatedAt: new Date().toISOString()
        });

        res.json({ success: true, message: 'Business analytics request updated successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error updating request:', error);
        res.status(500).json({ success: false, message: 'Failed to update business analytics request' });
    }
});

// DELETE /api/analysis/request/:requestId - Cancel analysis request
router.delete('/request/:requestId', async (req, res) => {
    try {
        const { requestId } = req.params;
        const userEmail = req.user.email;

        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const requestDoc = await adminDb.collection('analysis_requests').doc(requestId).get();
        if (!requestDoc.exists) return res.status(404).json({ success: false, message: 'Request not found' });

        const requestData = requestDoc.data();
        if (requestData.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Not authorized' });

        await adminDb.collection('analysis_requests').doc(requestId).delete();
        res.json({ success: true, message: 'Request cancelled successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error cancelling request:', error);
        res.status(500).json({ success: false, message: 'Failed to cancel request' });
    }
});

// GET /api/analysis/history - Get contractor's analysis history
router.get('/history', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const snapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .orderBy('createdAt', 'desc')
            .get();

        const requests = snapshot.docs.map(doc => {
            const data = doc.data();
            return {
                _id: doc.id, dataType: data.dataType || 'Production Update',
                frequency: data.frequency || 'Daily', description: data.description || '',
                googleSheetUrl: data.googleSheetUrl || '', vercelUrl: data.vercelUrl || null,
                status: data.vercelUrl ? 'completed' : 'pending',
                createdAt: data.createdAt, updatedAt: data.updatedAt
            };
        });

        res.json({ success: true, requests });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching history:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch history' });
    }
});

// === CLIENT DASHBOARD ENDPOINTS ===

// GET /api/analysis/dashboards - Get all approved dashboards for the logged-in contractor
router.get('/dashboards', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email not found' });

        const snapshot = await adminDb.collection('dashboards')
            .where('contractorEmail', '==', userEmail)
            .where('status', '==', 'approved')
            .get();

        const dashboards = snapshot.docs.map(doc => {
            const d = doc.data();
            return {
                _id: doc.id, title: d.title, description: d.description,
                frequency: d.frequency, charts: d.charts, sheetNames: d.sheetNames,
                createdAt: d.createdAt, approvedAt: d.approvedAt
            };
        });

        dashboards.sort((a, b) => new Date(b.approvedAt || b.createdAt) - new Date(a.approvedAt || a.createdAt));
        res.json({ success: true, dashboards });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching client dashboards:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboards' });
    }
});

// GET /api/analysis/dashboards/:id - Get single dashboard full data (approved only)
router.get('/dashboards/:id', async (req, res) => {
    try {
        const userEmail = req.user.email;
        const doc = await adminDb.collection('dashboards').doc(req.params.id).get();
        if (!doc.exists) return res.status(404).json({ success: false, message: 'Dashboard not found' });

        const data = doc.data();
        if (data.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Access denied' });
        if (data.status !== 'approved') return res.status(403).json({ success: false, message: 'Dashboard not yet approved' });

        res.json({
            success: true,
            dashboard: {
                _id: doc.id, title: data.title, description: data.description,
                frequency: data.frequency, charts: data.charts, sheetNames: data.sheetNames,
                createdAt: data.createdAt, approvedAt: data.approvedAt
            }
        });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching dashboard:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboard' });
    }
});

export default router;
