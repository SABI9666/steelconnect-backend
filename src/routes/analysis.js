// src/routes/analysis.js - Contractor Analytics Portal
import express from 'express';
import multer from 'multer';
import { authenticateToken } from '../middleware/authMiddleware.js';
import { adminDb } from '../config/firebase.js';
import { fetchSheetData, fetchGoogleSheetData, parseSpreadsheet, autoGenerateDashboardConfig, detectLinkType, generatePredictiveAnalysis } from '../utils/sheetAnalyzer.js';
import { forceSyncDashboard } from '../services/dashboardSyncService.js';

const router = express.Router();
const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 50 * 1024 * 1024 } });

// Firestore max document size is ~1MB. We aim to stay well under that.
const FIRESTORE_DOC_LIMIT = 900 * 1024; // 900KB safety margin

function estimateJsonSize(obj) {
    try {
        return Buffer.byteLength(JSON.stringify(obj), 'utf8');
    } catch {
        return Infinity;
    }
}

/**
 * Progressively trim dashboard data to fit under Firestore's document limit.
 * Removes secondary charts, then trims datasets, then trims predictive analysis.
 */
function trimToFit(dashboardData, limit) {
    let size = estimateJsonSize(dashboardData);
    if (size <= limit) return dashboardData;

    // Step 1: Remove secondary/extra charts (keep only primary per sheet)
    if (dashboardData.charts && dashboardData.charts.length > 1) {
        dashboardData.charts = dashboardData.charts.filter(c => !c.isSecondary);
        size = estimateJsonSize(dashboardData);
        if (size <= limit) return dashboardData;
    }

    // Step 2: Trim dataset rows in charts (keep first 200 data points)
    if (dashboardData.charts) {
        for (const chart of dashboardData.charts) {
            if (chart.labels && chart.labels.length > 200) {
                chart.labels = chart.labels.slice(0, 200);
            }
            if (chart.datasets) {
                for (const ds of chart.datasets) {
                    if (ds.data && ds.data.length > 200) {
                        ds.data = ds.data.slice(0, 200);
                    }
                }
            }
            chart.rowCount = Math.min(chart.rowCount || 0, 200);
        }
        size = estimateJsonSize(dashboardData);
        if (size <= limit) return dashboardData;
    }

    // Step 3: Strip moving averages from predictive analysis
    if (dashboardData.predictiveAnalysis && dashboardData.predictiveAnalysis.movingAverages) {
        dashboardData.predictiveAnalysis.movingAverages = {};
        size = estimateJsonSize(dashboardData);
        if (size <= limit) return dashboardData;
    }

    // Step 4: Strip full predictive analysis, keep only insights
    if (dashboardData.predictiveAnalysis) {
        dashboardData.predictiveAnalysis = {
            forecasts: (dashboardData.predictiveAnalysis.forecasts || []).slice(0, 3),
            correlations: null,
            anomalies: [],
            insights: (dashboardData.predictiveAnalysis.insights || []).slice(0, 10),
            movingAverages: {},
            seasonality: dashboardData.predictiveAnalysis.seasonality || null
        };
        size = estimateJsonSize(dashboardData);
        if (size <= limit) return dashboardData;
    }

    // Step 5: Further trim chart data to 100 rows
    if (dashboardData.charts) {
        for (const chart of dashboardData.charts) {
            if (chart.labels && chart.labels.length > 100) chart.labels = chart.labels.slice(0, 100);
            if (chart.datasets) {
                for (const ds of chart.datasets) {
                    if (ds.data && ds.data.length > 100) ds.data = ds.data.slice(0, 100);
                }
            }
            if (chart.kpis && chart.kpis.length > 4) chart.kpis = chart.kpis.slice(0, 4);
        }
    }

    return dashboardData;
}

// Protect all routes with authentication
router.use(authenticateToken);

// === CONTRACTOR SHEET UPLOAD - Auto-generates dashboard, sends to admin for approval ===
// Supports: file upload (.xlsx, .xls, .csv) AND/OR Google Sheet link
// POST /api/analysis/upload-sheet
router.post('/upload-sheet', upload.single('spreadsheet'), async (req, res) => {
    try {
        const userEmail = req.user.email;
        const userName = req.user.name || req.user.displayName || 'Unknown User';

        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email not found' });
        }

        const { title, frequency, description, dataType, googleSheetUrl, syncInterval } = req.body;
        const hasFile = !!req.file;
        const hasLink = !!(googleSheetUrl && googleSheetUrl.trim());

        if (!hasFile && !hasLink) {
            return res.status(400).json({ success: false, message: 'Please upload a spreadsheet file (.xlsx, .xls, .csv) or provide a Google Sheet link' });
        }

        let sheets = {};
        let sheetNames = [];
        let dashboardCharts = [];
        let fileName = '';
        let fileSize = 0;

        // Process uploaded file if present
        if (hasFile) {
            sheets = parseSpreadsheet(req.file.buffer, req.file.originalname);
            sheetNames = Object.keys(sheets);
            fileName = req.file.originalname;
            fileSize = req.file.size;

            if (sheetNames.length === 0) {
                return res.status(400).json({ success: false, message: 'No valid data found in the uploaded file. Please check your spreadsheet.' });
            }

            dashboardCharts = autoGenerateDashboardConfig(sheets, frequency || 'daily');

            if (dashboardCharts.length === 0) {
                return res.status(400).json({ success: false, message: 'Could not extract numeric data from the spreadsheet. Ensure columns have numeric values.' });
            }
        } else if (hasLink) {
            // Fetch data from linked sheet URL (Google Sheets, SharePoint, OneDrive)
            try {
                const linkType = detectLinkType(googleSheetUrl.trim());
                console.log(`[ANALYSIS] Fetching ${linkType} sheet data from: ${googleSheetUrl.trim().substring(0, 80)}...`);
                const result = await fetchSheetData(googleSheetUrl.trim());
                sheets = result.sheets;
                sheetNames = result.sheetNames;
                fileName = linkType === 'google' ? 'Google Sheet' : linkType === 'sharepoint' ? 'SharePoint File' : 'Linked Sheet';

                dashboardCharts = autoGenerateDashboardConfig(sheets, frequency || 'daily');
                console.log(`[ANALYSIS] Auto-generated ${dashboardCharts.length} charts from ${linkType} sheet`);

                if (dashboardCharts.length === 0) {
                    return res.status(400).json({ success: false, message: 'Could not extract numeric data from the linked sheet. Ensure it contains columns with numeric values.' });
                }
            } catch (sheetError) {
                console.error('[ANALYSIS] Sheet fetch error:', sheetError.message);
                return res.status(400).json({ success: false, message: sheetError.message });
            }
        }

        // Generate predictive analysis (forecasts, correlations, anomalies, insights)
        let predictiveAnalysis = null;
        try {
            predictiveAnalysis = generatePredictiveAnalysis(sheets, dashboardCharts);
            console.log(`[ANALYSIS] Predictive analysis: ${predictiveAnalysis.forecasts.length} forecasts, ${predictiveAnalysis.anomalies.length} anomaly groups, ${predictiveAnalysis.insights.length} insights`);
        } catch (paErr) {
            console.error('[ANALYSIS] Predictive analysis error (non-fatal):', paErr.message);
        }

        // Store in Firestore 'dashboards' collection with status 'pending' for admin approval
        let dashboardData = {
            title: title || (hasFile ? `Dashboard - ${fileName}` : 'Dashboard - Google Sheet'),
            description: description || '',
            dataType: dataType || 'Production Update',
            contractorEmail: userEmail,
            contractorName: userName,
            frequency: frequency || 'daily',
            fileName: fileName || null,
            fileSize: fileSize || 0,
            googleSheetUrl: hasLink ? googleSheetUrl.trim() : null,
            linkType: hasLink ? detectLinkType(googleSheetUrl.trim()) : null,
            syncInterval: hasLink ? (syncInterval || 'daily') : 'manual',
            lastSyncedAt: hasLink ? new Date().toISOString() : null,
            lastSyncStatus: hasLink ? 'success' : null,
            sheetNames,
            charts: dashboardCharts,
            predictiveAnalysis: predictiveAnalysis || null,
            status: 'pending',
            uploadedBy: 'contractor',
            createdBy: userEmail,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            approvedAt: null,
            approvedBy: null
        };

        // Trim data to fit within Firestore's 1MB document size limit
        dashboardData = trimToFit(dashboardData, FIRESTORE_DOC_LIMIT);
        const estimatedSize = estimateJsonSize(dashboardData);
        console.log(`[ANALYSIS] Dashboard data size: ~${(estimatedSize / 1024).toFixed(1)}KB (limit: ${(FIRESTORE_DOC_LIMIT / 1024).toFixed(0)}KB)`);

        const docRef = await adminDb.collection('dashboards').add(dashboardData);
        console.log(`[ANALYSIS] Contractor ${userEmail} uploaded ${hasFile ? 'file' : ''}${hasFile && hasLink ? ' + ' : ''}${hasLink ? 'Google Sheet link' : ''} -> Dashboard ${docRef.id} created (pending approval)`);

        const linkLabel = hasLink ? (detectLinkType(googleSheetUrl.trim()) === 'sharepoint' ? 'SharePoint' : 'linked sheet') : 'uploaded file';
        const syncMsg = hasLink && syncInterval !== 'manual' ? ` Auto-sync: ${syncInterval}.` : '';
        const message = `Dashboard auto-generated with ${dashboardCharts.length} charts from ${hasFile ? 'uploaded file' : linkLabel}! Sent to admin for approval.${syncMsg}`;

        res.json({
            success: true,
            message,
            dashboardId: docRef.id,
            chartsGenerated: dashboardCharts.length,
            sheetsProcessed: sheetNames.length
        });

    } catch (error) {
        console.error('[ANALYSIS] Sheet upload error:', error.message, error.stack);
        const msg = (error.message || '').toLowerCase();
        if (msg.includes('exceeds the maximum allowed size') || msg.includes('invalid_argument') || msg.includes('too large') || msg.includes('document size')) {
            res.status(400).json({ success: false, message: 'Your data is too large. Try uploading a smaller spreadsheet or fewer sheets.' });
        } else if (msg.includes('cfb') || msg.includes('corrupted') || msg.includes('unsupported') || msg.includes('file type')) {
            res.status(400).json({ success: false, message: 'Could not read this file. Please ensure it is a valid .xlsx, .xls, or .csv file.' });
        } else if (msg.includes('timeout') || msg.includes('abort') || msg.includes('econnreset')) {
            res.status(504).json({ success: false, message: 'The request timed out while processing your data. Try a smaller file or fewer sheets.' });
        } else if (msg.includes('not publicly shared') || msg.includes('requires authentication') || msg.includes('permission')) {
            res.status(400).json({ success: false, message: error.message });
        } else {
            res.status(500).json({ success: false, message: 'Failed to process your data. Please try again or upload a smaller file.' });
        }
    }
});

// GET /api/analysis/my-dashboards - Get all dashboards for this contractor (pending + approved + rejected)
router.get('/my-dashboards', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email not found' });

        const snapshot = await adminDb.collection('dashboards')
            .where('contractorEmail', '==', userEmail)
            .get();

        const dashboards = snapshot.docs.map(doc => {
            const d = doc.data();
            return {
                _id: doc.id,
                title: d.title,
                description: d.description,
                dataType: d.dataType || 'Production Update',
                frequency: d.frequency,
                fileName: d.fileName,
                googleSheetUrl: d.googleSheetUrl || null,
                linkType: d.linkType || null,
                syncInterval: d.syncInterval || 'manual',
                lastSyncedAt: d.lastSyncedAt || null,
                lastSyncStatus: d.lastSyncStatus || null,
                manualDashboardUrl: d.manualDashboardUrl || null,
                status: d.status,
                chartsCount: (d.charts || []).length,
                charts: d.status === 'approved' ? d.charts : null,
                predictiveAnalysis: d.status === 'approved' ? (d.predictiveAnalysis || null) : null,
                sheetNames: d.sheetNames,
                createdAt: d.createdAt,
                approvedAt: d.approvedAt,
                updatedAt: d.updatedAt
            };
        });

        dashboards.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        res.json({ success: true, dashboards });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching my-dashboards:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboards' });
    }
});

// POST /api/analysis/dashboard/:id/sync - Force re-sync a dashboard from its linked sheet
router.post('/dashboard/:id/sync', async (req, res) => {
    try {
        const userEmail = req.user.email;
        const doc = await adminDb.collection('dashboards').doc(req.params.id).get();
        if (!doc.exists) return res.status(404).json({ success: false, message: 'Dashboard not found' });

        const data = doc.data();
        if (data.contractorEmail !== userEmail) {
            return res.status(403).json({ success: false, message: 'Access denied' });
        }
        if (!data.googleSheetUrl) {
            return res.status(400).json({ success: false, message: 'Dashboard has no linked sheet URL to sync from' });
        }

        const result = await forceSyncDashboard(req.params.id);
        res.json(result);
    } catch (error) {
        console.error('[ANALYSIS] Sync error:', error.message);
        res.status(500).json({ success: false, message: error.message || 'Failed to sync dashboard' });
    }
});

// DELETE /api/analysis/dashboard/:id - Contractor can delete their own pending dashboard
router.delete('/dashboard/:id', async (req, res) => {
    try {
        const userEmail = req.user.email;
        const doc = await adminDb.collection('dashboards').doc(req.params.id).get();
        if (!doc.exists) return res.status(404).json({ success: false, message: 'Dashboard not found' });

        const data = doc.data();
        if (data.contractorEmail !== userEmail) {
            return res.status(403).json({ success: false, message: 'Access denied' });
        }
        if (data.status !== 'pending') {
            return res.status(400).json({ success: false, message: 'Can only delete pending dashboards' });
        }

        await adminDb.collection('dashboards').doc(req.params.id).delete();
        res.json({ success: true, message: 'Dashboard deleted successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error deleting dashboard:', error);
        res.status(500).json({ success: false, message: 'Failed to delete dashboard' });
    }
});

// === LEGACY ENDPOINTS (kept for backwards compatibility) ===

// GET /api/analysis/my-request - Get contractor's analysis request
router.get('/my-request', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email not found' });
        }

        const snapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .orderBy('createdAt', 'desc')
            .limit(1)
            .get();

        if (snapshot.empty) {
            return res.json({ success: true, request: null });
        }

        const doc = snapshot.docs[0];
        const data = doc.data();

        res.json({
            success: true,
            request: {
                _id: doc.id,
                dataType: data.dataType || 'Production Update',
                frequency: data.frequency || 'Daily',
                description: data.description || '',
                googleSheetUrl: data.googleSheetUrl || '',
                vercelUrl: data.vercelUrl || null,
                status: data.vercelUrl ? 'completed' : 'pending',
                adminNotes: data.adminNotes || '',
                createdAt: data.createdAt,
                updatedAt: data.updatedAt
            }
        });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching contractor request:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch analysis request' });
    }
});

// POST /api/analysis/submit-request - Submit new analysis request (legacy)
router.post('/submit-request', async (req, res) => {
    try {
        const { dataType, frequency, googleSheetUrl, description } = req.body;
        const userEmail = req.user.email;
        const userName = req.user.name || req.user.displayName || 'Unknown User';
        const userId = req.user.uid || req.user.id || null;

        if (!googleSheetUrl || !description) {
            return res.status(400).json({ success: false, message: 'Data source URL and description are required' });
        }
        if (!userEmail) {
            return res.status(400).json({ success: false, message: 'User email is required' });
        }
        if (!googleSheetUrl.includes('http')) {
            return res.status(400).json({ success: false, message: 'Please provide a valid URL' });
        }

        const existingSnapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .where('vercelUrl', '==', null)
            .get();

        if (!existingSnapshot.empty) {
            return res.status(400).json({ success: false, message: 'You already have a pending analysis request' });
        }

        const requestData = {
            contractorEmail: userEmail,
            contractorName: userName,
            dataType: dataType || 'Production Update',
            frequency: frequency || 'Daily',
            googleSheetUrl: googleSheetUrl,
            description: description,
            vercelUrl: null,
            adminNotes: '',
            status: 'pending',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        if (userId) requestData.contractorId = userId;

        const docRef = await adminDb.collection('analysis_requests').add(requestData);

        res.json({ success: true, message: 'Business analytics request submitted successfully', requestId: docRef.id });
    } catch (error) {
        console.error('[ANALYSIS] Error submitting request:', error);
        res.status(500).json({ success: false, message: 'Failed to submit business analytics request' });
    }
});

// PUT /api/analysis/request/:requestId - Update analysis request
router.put('/request/:requestId', async (req, res) => {
    try {
        const { requestId } = req.params;
        const { dataType, frequency, googleSheetUrl, description } = req.body;
        const userEmail = req.user.email;

        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const requestDoc = await adminDb.collection('analysis_requests').doc(requestId).get();
        if (!requestDoc.exists) return res.status(404).json({ success: false, message: 'Analysis request not found' });

        const requestData = requestDoc.data();
        if (requestData.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Not authorized' });
        if (requestData.vercelUrl) return res.status(400).json({ success: false, message: 'Cannot update after report has been uploaded' });

        await adminDb.collection('analysis_requests').doc(requestId).update({
            dataType: dataType || requestData.dataType,
            frequency: frequency || requestData.frequency,
            googleSheetUrl: googleSheetUrl || requestData.googleSheetUrl,
            description: description || requestData.description,
            updatedAt: new Date().toISOString()
        });

        res.json({ success: true, message: 'Business analytics request updated successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error updating request:', error);
        res.status(500).json({ success: false, message: 'Failed to update business analytics request' });
    }
});

// DELETE /api/analysis/request/:requestId - Cancel analysis request
router.delete('/request/:requestId', async (req, res) => {
    try {
        const { requestId } = req.params;
        const userEmail = req.user.email;

        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const requestDoc = await adminDb.collection('analysis_requests').doc(requestId).get();
        if (!requestDoc.exists) return res.status(404).json({ success: false, message: 'Request not found' });

        const requestData = requestDoc.data();
        if (requestData.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Not authorized' });

        await adminDb.collection('analysis_requests').doc(requestId).delete();
        res.json({ success: true, message: 'Request cancelled successfully' });
    } catch (error) {
        console.error('[ANALYSIS] Error cancelling request:', error);
        res.status(500).json({ success: false, message: 'Failed to cancel request' });
    }
});

// GET /api/analysis/history - Get contractor's analysis history
router.get('/history', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email is required' });

        const snapshot = await adminDb.collection('analysis_requests')
            .where('contractorEmail', '==', userEmail)
            .orderBy('createdAt', 'desc')
            .get();

        const requests = snapshot.docs.map(doc => {
            const data = doc.data();
            return {
                _id: doc.id, dataType: data.dataType || 'Production Update',
                frequency: data.frequency || 'Daily', description: data.description || '',
                googleSheetUrl: data.googleSheetUrl || '', vercelUrl: data.vercelUrl || null,
                status: data.vercelUrl ? 'completed' : 'pending',
                createdAt: data.createdAt, updatedAt: data.updatedAt
            };
        });

        res.json({ success: true, requests });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching history:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch history' });
    }
});

// === CLIENT DASHBOARD ENDPOINTS ===

// GET /api/analysis/dashboards - Get all approved dashboards for the logged-in contractor
router.get('/dashboards', async (req, res) => {
    try {
        const userEmail = req.user.email;
        if (!userEmail) return res.status(400).json({ success: false, message: 'User email not found' });

        const snapshot = await adminDb.collection('dashboards')
            .where('contractorEmail', '==', userEmail)
            .where('status', '==', 'approved')
            .get();

        const dashboards = snapshot.docs.map(doc => {
            const d = doc.data();
            return {
                _id: doc.id, title: d.title, description: d.description,
                frequency: d.frequency, charts: d.charts, sheetNames: d.sheetNames,
                predictiveAnalysis: d.predictiveAnalysis || null,
                manualDashboardUrl: d.manualDashboardUrl || null,
                createdAt: d.createdAt, approvedAt: d.approvedAt
            };
        });

        dashboards.sort((a, b) => new Date(b.approvedAt || b.createdAt) - new Date(a.approvedAt || a.createdAt));
        res.json({ success: true, dashboards });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching client dashboards:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboards' });
    }
});

// GET /api/analysis/dashboards/:id - Get single dashboard full data (approved only)
router.get('/dashboards/:id', async (req, res) => {
    try {
        const userEmail = req.user.email;
        const doc = await adminDb.collection('dashboards').doc(req.params.id).get();
        if (!doc.exists) return res.status(404).json({ success: false, message: 'Dashboard not found' });

        const data = doc.data();
        if (data.contractorEmail !== userEmail) return res.status(403).json({ success: false, message: 'Access denied' });
        if (data.status !== 'approved') return res.status(403).json({ success: false, message: 'Dashboard not yet approved' });

        res.json({
            success: true,
            dashboard: {
                _id: doc.id, title: data.title, description: data.description,
                frequency: data.frequency, charts: data.charts, sheetNames: data.sheetNames,
                manualDashboardUrl: data.manualDashboardUrl || null,
                predictiveAnalysis: data.predictiveAnalysis || null,
                linkType: data.linkType || null,
                syncInterval: data.syncInterval || 'manual',
                lastSyncedAt: data.lastSyncedAt || null,
                lastSyncStatus: data.lastSyncStatus || null,
                createdAt: data.createdAt, approvedAt: data.approvedAt
            }
        });
    } catch (error) {
        console.error('[ANALYSIS] Error fetching dashboard:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboard' });
    }
});

export default router;
